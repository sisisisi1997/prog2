<?xml version="1.0" encoding="utf-8"?>
<book xml:id="report_root" xmlns="http://docbook.org/ns/docbook" version="5.0">
	<title>Jegyzőkönyv a Magas szintű programozási nyelvek 2 tárgy heti feladataihoz</title>
	<chapter>
		<title>Globális megjegyzések</title>
		<para>Időpontok dokumentálása 2018.09.19-én kezdődött, ezelőtt nem találhatóak meg dátumok.</para>
		<para>
			A Jegyzőkönyv átvitele a txt fájlból ebbe az XML fájlba folyamatosan történik, amíg a txt fájl tartalma teljesen át nem kerül ide.
			Ezen idő alatt mindkettő különböző befejezettségi állapotban lehet a feladatok feltöltésekor.
		</para>
	</chapter>
	<chapter>
		<title>1. hét</title>
		<section>
			<title>Feladat: OO szemlélet</title>
			<itemizedlist>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>PolarGenerator.java</para></listitem>
							<listitem><para>PolarGenerator.class</para></listitem>
							<listitem><para>PolarGenerator.cpp</para></listitem>
							<listitem><para>PolarGeneratorCPP.run</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Megoldás:
						<itemizedlist>
							<listitem><para>Java kód forrása a https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf diájából</para></listitem>
							<listitem><para>Java kód kommentelve (kód megértésének demonstrálására)</para></listitem>
							<listitem><para>Kód átültetve C++-ba (változtatások: random számok forrása a C 'rand()' függvény, azonban ez nem 0 és 1 közötti számokat ad, ez javítva (rand() / RAND_MAX alakban))</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>Feladat: Yoda</title>
			<itemizedlist>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>Yoda.java</para></listitem>
							<listitem><para>Yoda.class</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Megoldás: Java program, amely
						<itemizedlist>
							<listitem><para>bekér egy stringet</para></listitem>
							<listitem><para>amennyiben a string tartalmazza a "foo" karaktersorozatot, az értékét null-ra állítja</para></listitem>
							<listitem><para>a stringet a "bar" karaktersorozathoz hasonlítja "bar.equals(str)" formában (amennyiben str már null, az ellenkező sorrend NullPointerException-t dobna)</para></listitem>
							<listitem><para></para></listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>Feladat: From Scratch</title>
			<itemizedlist>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>BBP.java</para></listitem>
							<listitem><para>BBP.class</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Megoldás:
						<itemizedlist>
							<listitem><para>A kód bekér egy indulópozíciót és egy hosszot, majd kiírja az indulópozíció + 1-től kezdve hosszon keresztül a pi hexadecimális jegyeit</para></listitem>
							<listitem>
								<para>Hibajavítás: A használt algoritmus helyessége függ a floating point arithmetic pontosságától a használt gépen, így a kiszámolt összes jegy helyett csak az első 4-et használja fel.</para>
								<para>Ennyi mindig helyesnek bizonyult, és a 32/64 bit váltakozáson kívül (talán ezzel együtt is, TODO: utánanézni) a JVM konzisztensen adja meg a típusok pontosságát.</para>
							</listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>Feladat: homokozó</title>
			<itemizedlist>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>LZW_servlet.java</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>servlet alap kódja megírva</para></listitem>
							<listitem><para>LZW binfa kódja folyamatban</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>Feladat: gagyi</title>
			<itemizedlist>
				<listitem><para>Elkezdve: 2018.09.19. (labor előtt)</para></listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>gagyi.java</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>használt osztály létrehozva</para></listitem>
							<listitem><para>Integer.java tanulmányozása folyamatban</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
	</chapter>
	<chapter>
		<title>5. hét</title>
		<section>
			<title>Feladat: JDK osztályok</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.17., labor előtt) Elkezdve</para></listitem>
							<listitem><para>(2018.10.17., labor előtt) boost linkelése a forrásfájllal sikertelen, keresés után: ABI verzió probléma van</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>JDKClasses.cpp</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>Feladat: Másoló-mozgató szemantika</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.16.) Elkezdve</para></listitem>
							<listitem><para>(2018.10.17., labor előtt) copy és move assignment és ctor implementálva, hibajavításra szorul</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>MasolMozgat.cpp</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>Feladat: Hibásan implementált RSA törése</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.16.) Elkezdve</para></listitem>
							<listitem><para>(2018.10.16.) RSA.java implementálva</para></listitem>
							<listitem><para>(2018.10.16.) RSAToro.java - kódolás és dekódolás implementálva, törés maradt hátra</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>RSA.java: a kulcspárokat generáló osztály.</para></listitem>
							<listitem><para>RSAToro.java: a szöveget titkosító, majd feltörő osztály.</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>Tutor: Nagy Márta</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>Feladat: Változó argumentumszámú ctor</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.17., labor előtt) Elkezdve</para></listitem>
							<listitem><para>(2018.10.17., labor előtt) valtarg.cpp a képfájl nevét bekéri</para></listitem>
							<listitem><para>(2018.10.17., labor előtt) libpng++ library feltelepítve, hogy tudja kezelni a képeket, linkelés megvalósítása hátravan</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>nlp.hpp: a Perceptron osztály fájlja</para></listitem>
							<listitem><para>valtarg.cpp: az fájl ami felhasználja a Perceptront</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>Feladat: Összefoglaló</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.17., labor előtt) Elkezdve</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem>
								<para>
									Összefoglaló.docx: a feladatban megadott bemutató
									(a "Másoló-mozgató szemantika" feladatról, elméletben és konkrét megvalósításban is)
								</para>
							</listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
	</chapter>
	<chapter>
		<title>6. hét</title>
		<section>
			<title>Feladat: gengszterek rendezése</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.23.) Elkezdve</para></listitem>
							<listitem><para>(2018.10.23.) Megoldva</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Megoldás:
					</para>
					<para>
						A kódrészlet a gengsztereket rendezi egy összehasonlító függvény alapján, ahol az összehasonlítás alapja a rendőrtől való távolság.
						Ezt az std::sort egy tudja megtenni, hogy átvesz egy függvényt paraméterként, mely az összehasonlítást végzi.
						Mivel csak szennyeznénk a használt scope-ot egy függvény nevesítésével erre a célra, az átadott függvény egy ún. lambda függvény, mely egy névtelen függvény.
						Három részből áll, az első [] között van, és meghatározza, hogy a lambda függvény a körülötte lévő scope-ból mely változókhoz fér hozzá ("this" és "cop").
						A második egy paraméterlista, amellyel meg kell hívni. Ez egy összehasonlító függvény esetén a két összehasonlítandó elem.
						A harmadik a függvény teste, mely kiszámolja a visszatérési értéket, rendezéshez használt összehasonlító függvény esetén 0, ha egyenlőek,
						pozitív ha az egyik elem "nagyobb", és negatív ha a másik elem "nagyobb" - ezen utóbbiak sorrendje implementációfüggő.
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>Feladat: Custom Allocator</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.24., labor előtt) Elkezdve</para></listitem>
							<listitem><para>(2018.10.24., labor előtt) Linkelt előadás végigolvasva</para></listitem>
							<listitem><para>(2018.10.24., labor előtt) Elakadás: mi pontosan a feladat?</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>Feladat: STL map érték szerinti rendezése</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.23.) Elkezdve</para></listitem>
							<listitem><para>(2018.10.23.) Leírás rész megcsinálva</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Leírás:
					</para>
					<para>
						A map értékek szerinti rendezését a gengszterek rendezéséhez hasonlóan az std::sort és egy lambda függvény segítségével tesszük meg.
						Ebben az esetben a [=] implicit "elkapja" a környező scope-ban lévő változókat érték szerint, paraméterként pedig két key-value pair-t kap meg.
						A key-value paireket a ".second" tagjuk alapján hasonlítja össze, mely a value-nak felel meg, így kapunk érték szerinti rendezést.
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>Feladat: Alternatív tabella rendezése</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.23.) Elkezdve</para></listitem>
							<listitem><para>(2018.10.23.) Leírás rész megcsinálva</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Leírás:
					</para>
					<para>
						A programban a Comparable&lt;T&gt; interface implementációja egy összehasonlító függvényt ad a rendezéshez két csapat között.
						Ez több szempontban is különbözik az eddigi C++-os összehasonlítás-rendezésektől, például az összehasonlítást végző függvény nevesítve van;
						az osztály példányának része ahelyett, hogy mindkét összehasonlítandó példányt paraméterként venné át; és mivel interface implementáció, már compile
						időben biztosított, hogy a megfelelő paramétereket veszi át és a megfelelő típussal tér vissza - hiszen ha nem így lenne, nem is ezt az interface-t
						implementálnánk, pedig a rendező függvény ilyen interface-t implementáló osztályokat vár bemenetnek.
						Magának az összehasonlításnak az elvégzéséhez a C++-hoz hasonlóan negatív, 0, és pozitív értékeket használ, ezzel az összetett adattípusainkat egyszerű
						egész számokká transzformálva, melyeket már tud rendezni a megadott rendezőalgoritmus.
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>Feladat: Összefoglaló</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.24., labor előtt) Elkezdve</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>Összefoglaló.docx: a feladatban megadott bemutató, az alternatív tabellás feladat Comparable&lt;T&gt; interface-éről</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
	</chapter>
	<chapter>
		<title>7. hét</title>
		<section>
			<title>1. feladat: FUTURE tevékenység editor</title>
			<itemizedlist>
				<listitem>
					Állapot:
					<itemizedlist>
						<listitem><para>(2018.11.07.) Elkezdve</para></listitem>
						<listitem><para>(2018.11.07.) Szükséges fájl leszedve githubról</para></listitem>
						<listitem><para>(2018.11.07.) Java FX-et nem találja a rendszert, telepíteni kell.</para></listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					Fájlok:
					<itemizedlist>
						<listitem><para>ActivityEditor.java: a future tevékenység editor.</para></listitem>
					</itemizedlist>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>2. feladat: OOCWC Boost ASIO hálózatkezelése</title>
			<itemizedlist>
				<listitem>
					Állapot:
					<itemizedlist>
						<listitem><para>(2018.11.07.) Elkezdve</para></listitem>
						<listitem><para>(2018.11.07.) Megoldva</para></listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>
						Megoldás:
					</para>
					<para>
						Az std::sscanf függvény arra alkalmas, hogy egy stringből egy bizonyos formátum alapján nyerjen ki adatokat.
						Minden egyes actionben ahol az sscanf jelen van, az éppen matchelt patternből változókba fogja kiolvasni az olyan adatokat, mint
						név (init), pozíciók (pos), stb, ezzel jóval leegyszerűsítve az adott bemenetből olvasó scanner működését ahhoz képest,
						mint ha kézzel kéne "darabolni" a stringeket.
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>3. feladat: SamuCam</title>
			<itemizedlist>
				<listitem>
					Állapot:
					<itemizedlist>
						<listitem><para>(2018.11.07.) Elkezdve</para></listitem>
						<listitem><para>(2018.11.07.) Megoldva</para></listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>
						Megoldás:
					</para>
					<para>
						A VideoCapture konstruktora egy stringet fogad, amely lehet egy eszköz eléréséhez annak indexe (0, 1, ...).
						Miután megnyitjuk a video streamet és beállítjuk a tulajdonságait (képméret, etc), frame-enként tudunk olvasni, feldolgozni,
						majd ugorni a következő frame-re.
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>4. feladat: BrainB</title>
			<itemizedlist>
				<listitem>
					Állapot:
					<itemizedlist>
						<listitem><para>(2018.11.07.) Elkezdve</para></listitem>
						<listitem><para>(2018.11.07.) Megoldva</para></listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>
						Megoldás:
					</para>
					<para>
						A Qt signals &amp; slots rendszere egy eseményekre (event) alapuló működést segít felépíteni, melyben az egyes objektumok tájékoztathatják
						egymást bizonyos eseményekről, pl. egy változó értékének módosításáról.
						Pl. a BrainB-ben mikor a BrainBThread draw() metódusa befejeződik, emit-el (kibocsájt) egy signalt, amit a BrainBWin fogad, és ennek megfelelően
						tud cselekedni. Ehhez több dolog is szükséges. Mivel alapból a slotok és signal-ök nem tudnak egymásról (decoupling és encapsulation elvét betartva),
						össze kell kötni őket a connect() metódussal, ami ebben az esetben a BrainBWin-ben van (mivel ő szeretne tájékozódni).
						Ezen kívül a signal és a hozzá kapcsolt slot signature-je meg kell, hogy egyezzen, így a megfelelő adatokat tudja továbbítani a signal a slot felé.
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>5. feladat: OSM térképre rajzolása (alternatíva elkészítése)</title>
			<itemizedlist>
				<listitem>
					Állapot:
					<itemizedlist>
						<listitem><para>(2018.11.07.) Elkezdve</para></listitem>
						<listitem><para>(2018.11.07.) GPS tracker elkezdve</para></listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					Fájlok:
					<itemizedlist>
						<listitem><para>GpsTracker.java</para></listitem>
					</itemizedlist>
				</listitem>
			</itemizedlist>
		</section>
	</chapter>
</book>