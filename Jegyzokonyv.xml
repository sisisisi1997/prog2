<?xml version="1.0" encoding="utf-8"?>
<book xml:id="report_root" xmlns="http://docbook.org/ns/docbook" version="5.0">
	<title>Jegyzőkönyv a Magas szintű programozási nyelvek 2 tárgy heti feladataihoz</title>
	<chapter>
		<title>Megjegyzések</title>
		<para>Időpontok dokumentálása 2018.09.19-én kezdődött, ezelőtt nem találhatóak meg dátumok.</para>
		<para>
			A Jegyzőkönyv átvitele a txt fájlból ebbe az XML fájlba folyamatosan történik, amíg a txt fájl tartalma teljesen át nem kerül ide.
			Ezen idő alatt mindkettő különböző befejezettségi állapotban lehet a feladatok feltöltésekor.
		</para>
		<para>a 3. héten a feladatok megoldásához használt laptop meghibásodott, így az akkori feladatok a 4. hetiek határidejéig lesznek pótolva</para>
		<para>
			Tutoráltak:
			<itemizedlist>
				<listitem><para>Nagy Márta</para></listitem>
				<listitem><para>Tar Zolti</para></listitem>
				<listitem><para>Tóth Norbert</para></listitem>
			</itemizedlist>
		</para>
	</chapter>
	<chapter>
		<title>1. hét</title>
		<section>
			<title>1. feladat: OO szemlélet</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>Java kód forrása a https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog1_5.pdf diájából</para></listitem>
							<listitem><para>Java kód kommentelve (kód megértésének demonstrálására)</para></listitem>
							<listitem><para>Kód átültetve C++-ba (változtatások: random számok forrása a C 'rand()' függvény, azonban ez nem 0 és 1 közötti számokat ad, ez javítva (rand() / RAND_MAX alakban))</para></listitem>
							<listitem><para>Befejezve</para></listitem>
							<listitem><para>(2018.11.28.) Screenshot hozzáadva a futásról java és C++ nyelvű programról.</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>PolarGenerator.java</para></listitem>
							<listitem><para>PolarGenerator.cpp</para></listitem>
							<listitem><para>OOSzeml_CPP.png</para></listitem>
							<listitem><para>OOSzeml_Java.png</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>2. feladat: Homokozó</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>servlet alap kódja megírva</para></listitem>
							<listitem><para>LZW binfa kódja folyamatban</para></listitem>
							<listitem><para>(2018.11.29.) LZW binfa kódja befejezve</para></listitem>
							<listitem><para>(2018.11.29.) Befejezve, fut</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>homokozo/LZW_servlet.java</para></listitem>
							<listitem><para>homokozo/LZWBinfa.java</para></listitem>
							<listitem><para>homokozo.png</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>3. feladat: gagyi</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.09.19.) Elkezdve</para></listitem>
							<listitem><para>(2018.19.19.) használt osztály létrehozva</para></listitem>
							<listitem><para>(2018.19.19.) Integer.java tanulmányozása folyamatban</para></listitem>
							<listitem><para>(2018.11.29.) Az Integer.java-ban található kód alapján a megfelelő értékhatárok meghatározva.</para></listitem>
							<listitem><para>(2018.11.29.) Befejezve</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>Gagyi.java</para></listitem>
							<listitem><para>gagyi.png</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Magyarázat: Java-ban a &lt;= és a &gt;= operátorok értéket hasonlítanak össze, azonban mivel az <code language="Java">Integer</code> nem primitív típus,
						hanem objektum, ezért az == és != operátorok memóriacímet hasonlítanak össze. Emiatt előfordulhat, hogy két különböző példány,
						melyek ugyanazzal az értékkel bírnak, igazra tesztelődnének a <code language="Java">while(x &gt;=t &amp;&amp; x &lt;= t &amp;&amp; x != t) {}</code>
						ciklus fejében. Az, hogy egyetlen példányt, vagy különböző példányokat kapunk, az a Java <code language="Java">IntegerCache.low</code> és
						<code language="Java">IntegerCache.high</code> értékétől függenek, eközött a két érték között (inklúzívan) az azonos értékű változók memóriaspórolás végett
						azonos memóriacímre mutatnak, hacsaknem explicit új példányt hozunk létre.
					</para>
					<para>
						Mivel az <code language="Java">int</code> típus primitív, ezért ezzel nem működik a "trükk", mindig értékösszehasonlítás történik - az Integerbe való wrapelés
						kötelező elem, amennyiben ilyen viselkedést szeretnénk elérni.
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>4. feladat: Yoda</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>Elkezdve</para></listitem>
							<listitem><para>Befejezve</para></listitem>
							<listitem><para>(2018.11.29.) Jegyzőkönyv formához igazítva</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>Yoda.java</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Megoldás: egy java program, amely
						<itemizedlist>
							<listitem><para>bekér egy stringet</para></listitem>
							<listitem><para>amennyiben a string tartalmazza a "foo" karaktersorozatot, az értékét null-ra állítja</para></listitem>
							<listitem><para>a stringet a "bar" karaktersorozathoz hasonlítja "bar.equals(str)" formában (amennyiben str már null, az ellenkező sorrend NullPointerException-t dobna)</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>5. feladat: From Scratch</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot: befejezve
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>BBP.java</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Megoldás:
						<itemizedlist>
							<listitem><para>A kód bekér egy indulópozíciót és egy hosszot, majd kiírja az indulópozíció + 1-től kezdve hosszon keresztül a pi hexadecimális jegyeit</para></listitem>
							<listitem>
								<para>Hibajavítás: A használt algoritmus helyessége függ a floating point arithmetic pontosságától a használt gépen, így a kiszámolt összes jegy helyett csak az első 4-et használja fel.</para>
								<para>Ennyi mindig helyesnek bizonyult, és a 32/64 bit váltakozáson kívül (talán ezzel együtt is, TODO: utánanézni) a JVM konzisztensen adja meg a típusok pontosságát.</para>
							</listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
	</chapter>
	<chapter>
		<title>2. hét</title>
		<section>
			<title>1. feladat: Liskov helyettesítés sértése</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.09.19.) Elkezdve</para></listitem>
							<listitem><para>(2018.09.19.) Tervezett megoldás: számok nagyobb/kisebb összehasonlítása, mely érvényes művelet a StringNumberben, de nem az a ComplexStringNumberben</para></listitem>
							<listitem><para>(???????????) StringNumber implementálva</para></listitem>
							<listitem><para>(2018.11.30.) ComplexStringNumber implementálva</para></listitem>
							<listitem><para>(2018.11.30.) java implementáció befejezve, mely szándékosan exceptionnel leáll.</para></listitem>
							<listitem><para>(2018.11.30.) C++ implementáció befejezve, mely szándékosan exceptionnel leáll.</para></listitem>
							<listitem><para>(2018.11.30.) Befejezve</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>Liskov.java</para></listitem>
							<listitem><para>helper/StringNumber.java</para></listitem>
							<listitem><para>helper/ComplexStringNumber.java</para></listitem>
							<listitem><para>Liskov.cpp</para></listitem>
							<listitem><para>StringNumber.cpp</para></listitem>
							<listitem><para>StringNumber.hpp</para></listitem>
							<listitem><para>ComplexStringNumber.cpp</para></listitem>
							<listitem><para>ComplexStringNumber.hpp</para></listitem>
							<listitem><para>liskov_java.png</para></listitem>
							<listitem><para>liskov_cpp.png</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Megoldás: Két osztály létrehozása, mely a számokat stringként kezeli. A szülőosztály racionális számokkal dolgozik, míg a gyermekosztály komplex számokkal.
						Ebben az esetben a szülőosztályban definiálva vannak az <code language="Java">isGreaterThan(), isLessThan(), isEqualTo()</code> metódusok összehasonlításokhoz,
						azonban a gyermekosztályban ezek közül az <code language="Java">isGreaterThan(), isLessThan()</code> nem értelmezhetőek matematikailag.
					</para>
					<para>
						A hiba kijavítható lenne a tervezés megváltoztatásával: a gyermekosztályok feladat nem a szülő általánosítása, hanem annak specializálása. Mivel a komplex számok
						általánosabbak ("superset of"), mint a racionális számok, ezért a komplex számokat kezelő osztálynak kéne a szülőnek lennie, a racionálisnak pedig a gyermeknek.
						A szülő osztályban csak az <code language="Java">isEqualTo()</code> lenne definiálva, a másik kettő pedig csak a gyermekosztályban.
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>2. feladat: Szülő-gyerek</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.09.26.) Elkezdve</para></listitem>
							<listitem><para>(2018.09.26.) Implementáció hibás, javítás alatt</para></listitem>
							<listitem><para>(2018.11.30.) Java implementáció kijavítva</para></listitem>
							<listitem><para>(2018.11.30.) C++ implementáció megvalósítva</para></listitem>
							<listitem><para>(2018.11.30.) Befejezve</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>helper/Szulo.java</para></listitem>
							<listitem><para>helper/Gyerek.java</para></listitem>
							<listitem><para>SZGYMain.java</para></listitem>
							<listitem><para>SZGY.cpp</para></listitem>
							<listitem><para>SZGY_cpp.png</para></listitem>
							<listitem><para>SZGY_java_casttal.png</para></listitem>
							<listitem><para>SZGY_java_hiba.png</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>3. feladat: Anti OO</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.09.26.) Elkezdve</para></listitem>
							<listitem><para>(2018.09.26.) C++ és Java implementáció elkezdve</para></listitem>
							<listitem><para>(2018.09.26.) a jelenlegi BBP algoritmus implementáció a kért számjegy-számhoz túl lassú, optimalizáció szükséges</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>BBPTimer.java</para></listitem>
							<listitem><para>BBPTimer.cpp</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Megjegyzések:
						<itemizedlist>
							<listitem><para>a különböző nyelvek között használt implementáció (logikailag) meg kell, hogy egyezzen ahhoz, hogy a mérés reprezentatív legyen arra nézve, hogy mi maga a futási sebesség közötti különbség</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>4. feladat: Hello, Android!</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.09.26.) Elkezdve</para></listitem>
							<listitem><para>(2018.09.26.) Samu-Entropy leszedve githubról. Átnézés folyamatban.</para></listitem>
							<listitem><para>(2018.11.30.) Projektek beimportálva android studioba.</para></listitem>
							<listitem><para>(2018.11.30.) Projektek felélesztve.</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok: samu_1.jpeg - samu_10.jpeg
					</para>
				</listitem>
				<listitem>
					<para>
						
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>5. feladat: Ciklomatikus komplexitás</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.09.26.) Elkezdve</para></listitem>
							<listitem><para>(2018.09.26.) használt képlet a wikipédián talált. Kiválasztott metódus elemzésre: helper.StringNumber.isGreaterThan()</para></listitem>
							<listitem><para>(2018.11.30.) Befejezve</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok: gráf.png
					</para>
				</listitem>
				<listitem>
					<para>
						Megoldás:
						<para>
							Gráf:
							<itemizedlist>
								<listitem><para>1: kiindulópont</para></listitem>
								<listitem><para>2: elágazás - előjel vizsgálata</para></listitem>
								<listitem><para>3: elágazás - egészrészek egyenlősége</para></listitem>
								<listitem><para>8: ciklus - egészrész egyenlősége</para></listitem>
								<listitem><para>5: elágazás - egészrész egyenlősége</para></listitem>
								<listitem><para>4: ciklus - törtrész egyenlősége</para></listitem>
								<listitem><para>6: elágazás - törtrész egyenlősége</para></listitem>
								<listitem><para>7: végpont - visszatérés egy értékkel</para></listitem>
							</itemizedlist>
						</para>
					</para>
				</listitem>
			</itemizedlist>
		</section>
	</chapter>
	<chapter>
		<title>3. hét</title>
		<section>
			<title>2. feladat: Forward engineering UML osztálydiagram</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.09.) Elkezdve</para></listitem>
							<listitem><para>(2018.10.09.) Befejezve</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>forward.zargo</para></listitem>
							<listitem><para>HeadPhone.h</para></listitem>
							<listitem><para>HeadPhone.cpp</para></listitem>
							<listitem><para>HeadPhoneManufacturer.h</para></listitem>
							<listitem><para>HeadPhoneManufacturer.cpp</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Megoldás: ArgoUML program segítségével készítettem két osztálydiagramot, amelyek leírják a HeadPhone és a HeadPhoneManufacturer osztályt.
						Az osztályok tartalmaznak private elemeket, public gettereket ezekhez az elemekhez, és egy-egy konstruktort,
						melyeket az ArgoUML az osztálydiagramok alapján generált.
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>4. feladat: BPMN</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.09.) Elkezdve</para></listitem>
							<listitem><para>(2018.10.09.) Befejezve</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>bpmn.jpg</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Megoldás: BPMN diagram feladatmegoldásról programozás laborra, melynek elemei a következők:
						Kezdőesemény: közeledik a feladatok beadási határideje.
						Tevékenység: egy feladat elvégzése.
						Útválasztó: Van még hátra feladat?
						Tevékenység: feladatok feltöltése githubra.
						Befejező esemény: az óra során a feladatok bemutathatóak.
						Az elemek olvashatósági okokból vannak leírva a jegyzőkönyvbe, a köztük lévő kapcsolatok csak a bpmn.jpg-ben találhatóak meg.
					</para>
				</listitem>
			</itemizedlist>
		</section>
	</chapter>
	<chapter>
		<title>4. hét</title>
		<section> <!-- TODO: megcsinálni azért, valahogy... -->
			<title>1. feladat: Encoding</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.03.) Elkezdve</para></listitem>
							<listitem><para>(2018.10.03.) Befejezve</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>MandelbrotHalmaz.java</para></listitem>
							<listitem><para>MandelbrotHalmazNagyító.java</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Megoldás: Az ubuntu terminál alapértelmezett karakterkódolása UTF-8, így nem okozott problémát a fájlnév továbbítása a javac felé parancssori argumentumként.
						Amennyiben a karakterkódolással gond lett volna, meg lehetne változtatni az $LC_ALL és a $LANG környezeti változók beállításával.
						Amennyiben a bemeneti fájl kódolását nem ismeri fel a javac, akkor a "javac -encoding encoding_name filename.java" paranccsal fordítható le a forráskód.
						Ellenpélda az alapértelmezett beállításokkal való helyes működésre pl. a Windows XP command line, itt kifejtve:
						https://stackoverflow.com/questions/5993979/error-compiling-java-file-with-special-characters-in-class-name
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>3. feladat: l33ts1c4</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.03.) Elkezdve</para></listitem>
							<listitem><para>(2018.10.03.) Befejezve</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>L334.java</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Megoldás: Bekérek egy bemenetet a terminálból, felvágom szóközök mentén szavakra.
						Végigmegyek minden szón, és ha az szerepel a szótranszformációs hashmapben, akkor kicserélem egyben.
						Azokon a szavakon, amelyek nem szerepeltek, betűnként megyek végig, és a betűtranszformációs hashmap segítségével kicserélem az érintett betűket egyesével.
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>4. feladat: Full screen</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.10.) Elkezdve</para></listitem>
							<listitem><para>(2018.10.10.) Befejezve</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>Fullscreen.java</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
	</chapter>
	<chapter>
		<title>5. hét</title>
		<section>
			<title>1. feladat: JDK osztályok</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.17., labor előtt) Elkezdve</para></listitem>
							<listitem><para>(2018.10.17., labor előtt) boost linkelése a forrásfájllal sikertelen, keresés után: ABI verzió probléma van</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>JDKClasses.cpp</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>2. feladat: Másoló-mozgató szemantika</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.16.) Elkezdve</para></listitem>
							<listitem><para>(2018.10.17., labor előtt) copy és move assignment és ctor implementálva, hibajavításra szorul</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>MasolMozgat.cpp</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>3. feladat: Hibásan implementált RSA törése</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.16.) Elkezdve</para></listitem>
							<listitem><para>(2018.10.16.) RSA.java implementálva</para></listitem>
							<listitem><para>(2018.10.16.) RSAToro.java - kódolás és dekódolás implementálva, törés maradt hátra</para></listitem>
							<listitem><para>(2018.11.30.) Törés implementálva</para></listitem>
							<listitem><para>(2018.11.30.) Befejezve</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>RSA.java: a kulcspárokat generáló osztály.</para></listitem>
							<listitem><para>RSAToro.java: a szöveget titkosító, majd feltörő osztály.</para></listitem>
							<listitem><para>RSAtoro.png</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>Tutor: Nagy Márta</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>Feladat: Változó argumentumszámú ctor</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.17., labor előtt) Elkezdve</para></listitem>
							<listitem><para>(2018.10.17., labor előtt) valtarg.cpp a képfájl nevét bekéri</para></listitem>
							<listitem><para>(2018.10.17., labor előtt) libpng++ library feltelepítve, hogy tudja kezelni a képeket, linkelés megvalósítása hátravan</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>nlp.hpp: a Perceptron osztály fájlja</para></listitem>
							<listitem><para>valtarg.cpp: az fájl ami felhasználja a Perceptront</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>Feladat: Összefoglaló</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.17., labor előtt) Elkezdve</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem>
								<para>
									Összefoglaló.docx: a feladatban megadott bemutató
									(a "Másoló-mozgató szemantika" feladatról, elméletben és konkrét megvalósításban is)
								</para>
							</listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
	</chapter>
	<chapter>
		<title>6. hét</title>
		<section>
			<title>Feladat: gengszterek rendezése</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.23.) Elkezdve</para></listitem>
							<listitem><para>(2018.10.23.) Megoldva</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Megoldás:
					</para>
					<para>
						A kódrészlet a gengsztereket rendezi egy összehasonlító függvény alapján, ahol az összehasonlítás alapja a rendőrtől való távolság.
						Ezt az std::sort egy tudja megtenni, hogy átvesz egy függvényt paraméterként, mely az összehasonlítást végzi.
						Mivel csak szennyeznénk a használt scope-ot egy függvény nevesítésével erre a célra, az átadott függvény egy ún. lambda függvény, mely egy névtelen függvény.
						Három részből áll, az első [] között van, és meghatározza, hogy a lambda függvény a körülötte lévő scope-ból mely változókhoz fér hozzá ("this" és "cop").
						A második egy paraméterlista, amellyel meg kell hívni. Ez egy összehasonlító függvény esetén a két összehasonlítandó elem.
						A harmadik a függvény teste, mely kiszámolja a visszatérési értéket, rendezéshez használt összehasonlító függvény esetén 0, ha egyenlőek,
						pozitív ha az egyik elem "nagyobb", és negatív ha a másik elem "nagyobb" - ezen utóbbiak sorrendje implementációfüggő.
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>Feladat: Custom Allocator</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.24., labor előtt) Elkezdve</para></listitem>
							<listitem><para>(2018.10.24., labor előtt) Linkelt előadás végigolvasva</para></listitem>
							<listitem><para>(2018.10.24., labor előtt) Elakadás: mi pontosan a feladat?</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>Feladat: STL map érték szerinti rendezése</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.23.) Elkezdve</para></listitem>
							<listitem><para>(2018.10.23.) Leírás rész megcsinálva</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Leírás:
					</para>
					<para>
						A map értékek szerinti rendezését a gengszterek rendezéséhez hasonlóan az std::sort és egy lambda függvény segítségével tesszük meg.
						Ebben az esetben a [=] implicit "elkapja" a környező scope-ban lévő változókat érték szerint, paraméterként pedig két key-value pair-t kap meg.
						A key-value paireket a ".second" tagjuk alapján hasonlítja össze, mely a value-nak felel meg, így kapunk érték szerinti rendezést.
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>Feladat: Alternatív tabella rendezése</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.23.) Elkezdve</para></listitem>
							<listitem><para>(2018.10.23.) Leírás rész megcsinálva</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Leírás:
					</para>
					<para>
						A programban a Comparable&lt;T&gt; interface implementációja egy összehasonlító függvényt ad a rendezéshez két csapat között.
						Ez több szempontban is különbözik az eddigi C++-os összehasonlítás-rendezésektől, például az összehasonlítást végző függvény nevesítve van;
						az osztály példányának része ahelyett, hogy mindkét összehasonlítandó példányt paraméterként venné át; és mivel interface implementáció, már compile
						időben biztosított, hogy a megfelelő paramétereket veszi át és a megfelelő típussal tér vissza - hiszen ha nem így lenne, nem is ezt az interface-t
						implementálnánk, pedig a rendező függvény ilyen interface-t implementáló osztályokat vár bemenetnek.
						Magának az összehasonlításnak az elvégzéséhez a C++-hoz hasonlóan negatív, 0, és pozitív értékeket használ, ezzel az összetett adattípusainkat egyszerű
						egész számokká transzformálva, melyeket már tud rendezni a megadott rendezőalgoritmus.
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>Feladat: Összefoglaló</title>
			<itemizedlist>
				<listitem>
					<para>
						Állapot:
						<itemizedlist>
							<listitem><para>(2018.10.24., labor előtt) Elkezdve</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
				<listitem>
					<para>
						Fájlok:
						<itemizedlist>
							<listitem><para>Összefoglaló.docx: a feladatban megadott bemutató, az alternatív tabellás feladat Comparable&lt;T&gt; interface-éről</para></listitem>
						</itemizedlist>
					</para>
				</listitem>
			</itemizedlist>
		</section>
	</chapter>
	<chapter>
		<title>7. hét</title>
		<section>
			<title>1. feladat: FUTURE tevékenység editor</title>
			<itemizedlist>
				<listitem>
					Állapot:
					<itemizedlist>
						<listitem><para>(2018.11.07.) Elkezdve</para></listitem>
						<listitem><para>(2018.11.07.) Szükséges fájl leszedve githubról</para></listitem>
						<listitem><para>(2018.11.07.) Java FX-et nem találja a rendszert, telepíteni kell.</para></listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					Fájlok:
					<itemizedlist>
						<listitem><para>ActivityEditor.java: a future tevékenység editor.</para></listitem>
					</itemizedlist>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>2. feladat: OOCWC Boost ASIO hálózatkezelése</title>
			<itemizedlist>
				<listitem>
					Állapot:
					<itemizedlist>
						<listitem><para>(2018.11.07.) Elkezdve</para></listitem>
						<listitem><para>(2018.11.07.) Megoldva</para></listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>
						Megoldás:
					</para>
					<para>
						Az std::sscanf függvény arra alkalmas, hogy egy stringből egy bizonyos formátum alapján nyerjen ki adatokat.
						Minden egyes actionben ahol az sscanf jelen van, az éppen matchelt patternből változókba fogja kiolvasni az olyan adatokat, mint
						név (init), pozíciók (pos), stb, ezzel jóval leegyszerűsítve az adott bemenetből olvasó scanner működését ahhoz képest,
						mint ha kézzel kéne "darabolni" a stringeket.
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>3. feladat: SamuCam</title>
			<itemizedlist>
				<listitem>
					Állapot:
					<itemizedlist>
						<listitem><para>(2018.11.07.) Elkezdve</para></listitem>
						<listitem><para>(2018.11.07.) Megoldva</para></listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>
						Megoldás:
					</para>
					<para>
						A VideoCapture konstruktora egy stringet fogad, amely lehet egy eszköz eléréséhez annak indexe (0, 1, ...).
						Miután megnyitjuk a video streamet és beállítjuk a tulajdonságait (képméret, etc), frame-enként tudunk olvasni, feldolgozni,
						majd ugorni a következő frame-re.
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>4. feladat: BrainB</title>
			<itemizedlist>
				<listitem>
					Állapot:
					<itemizedlist>
						<listitem><para>(2018.11.07.) Elkezdve</para></listitem>
						<listitem><para>(2018.11.07.) Megoldva</para></listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>
						Megoldás:
					</para>
					<para>
						A Qt signals &amp; slots rendszere egy eseményekre (event) alapuló működést segít felépíteni, melyben az egyes objektumok tájékoztathatják
						egymást bizonyos eseményekről, pl. egy változó értékének módosításáról.
						Pl. a BrainB-ben mikor a BrainBThread draw() metódusa befejeződik, emit-el (kibocsájt) egy signalt, amit a BrainBWin fogad, és ennek megfelelően
						tud cselekedni. Ehhez több dolog is szükséges. Mivel alapból a slotok és signal-ök nem tudnak egymásról (decoupling és encapsulation elvét betartva),
						össze kell kötni őket a connect() metódussal, ami ebben az esetben a BrainBWin-ben van (mivel ő szeretne tájékozódni).
						Ezen kívül a signal és a hozzá kapcsolt slot signature-je meg kell, hogy egyezzen, így a megfelelő adatokat tudja továbbítani a signal a slot felé.
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>5. feladat: OSM térképre rajzolása (alternatíva elkészítése)</title>
			<itemizedlist>
				<listitem>
					Állapot:
					<itemizedlist>
						<listitem><para>(2018.11.07.) Elkezdve</para></listitem>
						<listitem><para>(2018.11.07.) GPS tracker elkezdve</para></listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					Fájlok:
					<itemizedlist>
						<listitem><para>GpsTracker.java</para></listitem>
					</itemizedlist>
				</listitem>
			</itemizedlist>
		</section>
	</chapter>
	<chapter>
		<title>8. hét</title>
		<section>
			<title>1. feladat: Port scan</title>
			<itemizedlist>
				<listitem>
					Állapot:
					<itemizedlist>
						<listitem><para>(2018.11.13.) Elkezdve</para></listitem>
						<listitem><para>(2018.11.13.) Befejezve</para></listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					<para>
						Megoldás:
					</para>
					<para>
						Ebben a példában a kivételkezelés szerepe eltér annak alapértelmezett feladatától. Míg alapesetben nem számítunk arra, hogy kivétel történik, az ténylegesen
						"kivételes" esetben fordul elő hiba esetén, itt válogatási céllal van jelen - a
						<programlisting language="java"><![CDATA[java.net.Socket socket = new java.net.Socket(args[0], i);]]></programlisting>
						soron az inicializáláskor amennyiben az adott socket nem érhető el, kivételt emel a konstruktor.
						Ha ez nem történik meg, onnan tudjuk hogy az elérés sikeres, így nyitva van a socket.
					</para>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>2. feladat: AOP</title>
			<itemizedlist>
				<listitem>
					Állapot:
					<itemizedlist>
						<listitem><para>(2018.11.13.) Elkezdve</para></listitem>
						<listitem><para>(2018.11.13.) LZW binfa java-ban implementálva</para></listitem>
						<listitem><para>(2018.11.13.) aspectj telepítve, .as fájl megírva</para></listitem>
						<listitem>
							<para>
								(2018.11.13.) Ismeretlen okból akkor is ClassNotFoundExceptionnel leáll a program, ha a megfelelő jar fájlok benne vannak a classpathban.
								Javításra szorul.
							</para>
						</listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					Fájlok:
					<itemizedlist>
						<listitem><para>LZWBinfa.java</para></listitem>
						<listitem><para>AOP.aj</para></listitem>
					</itemizedlist>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>3. feladat: Android Játék</title>
			<itemizedlist>
				<listitem>
					Állapot:
					<itemizedlist>
						<listitem><para>(2018.11.07.) Elkezdve laboron</para></listitem>
						<listitem><para>(2018.11.07.) Projekt létrehozva</para></listitem>
					</itemizedlist>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>4. feladat: Junit teszt</title>
			<itemizedlist>
				<listitem>
					Állapot:
					<itemizedlist>
						<listitem><para>(2018.11.14.) Elkezdve</para></listitem>
						<listitem><para>(2018.11.14.) Junit.jar telepítve</para></listitem>
						<listitem><para>(2018.11.14.) teszt fájl létrehozva</para></listitem>
						<listitem><para>(2018.11.14.) LZWBinfa osztály fordításában ismeretlen hiba, javítani.</para></listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					Fájlok:
					<itemizedlist>
						<listitem><para>LZWBinfa.java</para></listitem>
						<listitem><para>JUnitTest.java</para></listitem>
						<listitem><para>JUnitTestRunner.java</para></listitem>
					</itemizedlist>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>5. feladat: Összefoglaló</title>
			<itemizedlist>
				<listitem>
					Állapot:
					<itemizedlist>
						<listitem><para>(2018.11.14.) Elkezdve</para></listitem>
						<listitem><para>(2018.11.14.) Témaválasztás: android játék feladat</para></listitem>
						<listitem><para>(2018.11.14.) Befejezve</para></listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					Fájlok:
					<itemizedlist>
						<listitem><para>összefoglaló.docx</para></listitem>
					</itemizedlist>
				</listitem>
			</itemizedlist>
		</section>
	</chapter>
	<chapter>
		<title>9. hét</title>
		<section>
			<title>1. feladat: MNIST</title>
			<itemizedlist>
				<listitem>
					Állapot:
					<itemizedlist>
						<listitem><para>(2018.10.20.) Elkezdve</para></listitem>
						<listitem><para>(2018.10.20.) Saját képek elkészítve teszteléshez (hetes, hármas számjegy, valamint egy random ábra)</para></listitem>
						<listitem><para>(2018.10.21.) megfelelő modulok telepítése a pythonhoz (tensorflow, mathplotlib, setuptools)</para></listitem>
						<listitem><para>(2018.10.21.) módosítások végzése a mnist.py-on, hogy felélesszem</para></listitem>
						<listitem><para>(2018.10.21.) a mnist lefut, azonban nagy arányban téveszt - mélyebb ismeretek hiánya miatt a témában ezen nem tudok javítani</para></listitem>
						<listitem><para>(2018.10.21.) Befejezve</para></listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					Fájlok:
					<itemizedlist>
						<listitem><para>mnist.py</para></listitem>
						<listitem><para>hetes.png és .xcf</para></listitem>
						<listitem><para>hetes-kezi.png</para></listitem>
						<listitem><para>harmas-kezi.png és .xcf</para></listitem>
						<listitem><para>random.png és .xcf</para></listitem>
						<listitem><para>pics/mnist.png</para></listitem>
					</itemizedlist>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>2. feladat: Deep MNIST</title>
			<itemizedlist>
				<listitem>
					Állapot:
					<itemizedlist>
						<listitem><para>(2018.10.21.) Elkezdve</para></listitem>
						<listitem><para>(2018.10.21.) Elakadás, hogyan értékelek ki képet a "deep" verzióban?</para></listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					Fájlok:
					<itemizedlist>
						<listitem><para>mnist_deep.py</para></listitem>
						<listitem><para>pics/mnist_deep.png</para></listitem>
					</itemizedlist>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>3. feladat: CIFAR-10</title>
			<itemizedlist>
				<listitem>
					Állapot:
					<itemizedlist>
						<listitem><para>(2018.10.21.) Elkezdve</para></listitem>
						<listitem><para>(2018.10.21.) cifar10-es példa megkeresve a tensorflow repoban</para></listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					Fájlok:
					<itemizedlist>
						<listitem><para>cifar10.py</para></listitem>
					</itemizedlist>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>4. feladat: Android telefonra a TF objektum detektálója</title>
			<itemizedlist>
				<listitem>
					Állapot:
					<itemizedlist>
						<listitem><para>(2018.10.21.) Elkezdve</para></listitem>
						<listitem><para>(2018.10.21.) Hiányzó sdk/build-tools feltelepítése az android studiohoz</para></listitem>
						<listitem><para>(2018.10.21.) Demo alkalmazások feltelepítése telefonra, kipróbálás</para></listitem>
						<listitem><para>(2018.10.21.) Befejezve</para></listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					Fájlok:
					<itemizedlist>
						<listitem><para>pics/TF_Android.jpeg</para></listitem>
					</itemizedlist>
				</listitem>
			</itemizedlist>
		</section>
		<section>
			<title>5. feladat: Összefoglaló</title>
			<itemizedlist>
				<listitem>
					Állapot:
					<itemizedlist>
						<listitem><para>(2018.10.21.) Elkezdve</para></listitem>
						<listitem><para>(2018.10.21.) Kiválasztott feladat: MNIST</para></listitem>
						<listitem><para>(2018.10.21.) Általános leírás kész</para></listitem>
						<listitem><para>(2018.10.21.) Tapasztalt hibák leírása kész</para></listitem>
					</itemizedlist>
				</listitem>
				<listitem>
					Fájlok:
					<itemizedlist>
						<listitem><para>osszefoglalo.docx</para></listitem>
					</itemizedlist>
				</listitem>
			</itemizedlist>
		</section>
	</chapter>
</book>